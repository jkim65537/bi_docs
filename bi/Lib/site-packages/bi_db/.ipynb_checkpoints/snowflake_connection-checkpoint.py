import sys
import pandas as pd
import snowflake.connector
from db_connection import dbConnection
from redshift_connection import RedshiftConnection

from bi_tools import Logger
logger = Logger("debug")

from biz_intel_creds import CredsList
CredsList.snowflake = {"username":"junkim", "pw":"Pitchbook123", "account":"pitchbook"}
snowflake_creds = CredsList().snowflake

class SnowflakeConnection(dbConnection):
    def __init__(self, connection_type="sqlalchemy"):
        logger.custom_log("Connecting to Snowflake with {ctype}".format(
            ctype=connection_type
            )
        )
        if connection_type == "sqlalchemy":
            ctype = "snowflake"
            super(RedshiftConnection, self).__init__(connection_type=ctype,
                                                    creds=snowflake_creds)
        elif connection_type == "snowflake":
            self.cnx = snowflake.connector.connect(
                            user=config.SNOWFLAKE_CONFIG['USER'],
                            password=config.SNOWFLAKE_CONFIG['PASSWORD'],
                            account=config.SNOWFLAKE_CONFIG['ACCOUNT'],
                        )
            self.engine = self.cnx.cursor()
        else:
            raise SnowflakeException("invalid connection_type. "\
                "Choose between 'sqlalchemy' & 'snowflake'"
            )
        logger.custom_log("Connected successfully")

    def create(self, object_name, object_type=None, **kwargs):
        """
        object_type = (DATABASE, SCHEMA, WAREHOUSE)
        """
        if object_type is None:
            raise SnowflakeException("object type must be one of "\
                                        "['DATABASE', 'SCHEMA', 'WAREHOUSE']"
                                    )
        elif object_type.upper() in ["DATABASE", "WAREHOUSE"]:
            self.engine().execute("CREATE {ot} IF NOT EXISTS {on}".format(
                ot=object_type, on=object_name
                )
            )
            logger.custom_log("{ot} successfully created.".format(
                ot=object_type
                )
            )
        elif object_type.upper() == "SCHEMA":
            self.engine().execute("USE DATABASE {db_name}".format(
                db_name=kwargs["DATABASE"]
                )
            )
            self.engine().execute("CREATE {ot} IF NOT EXISTS {on}".format(
                ot=object_type, on=object_name
                )
            )
            logger.custom_log("{ot} successfully created.".format(
                ot=object_type
                )
            )

    def timeit(method):
        def timed(*args, **kw):
            ts = time.time()
            result = method(*args, **kw)
            te = time.time()
            if 'log_time' in kw:
                name = kw.get('log_name', method.__name__.upper())
                kw['log_time'][name] = int((te - ts) * 1000)
            else:
                print '%r  %2.2f ms' % \
                      (method.__name__, (te - ts) * 1000)
            return result
        return timed

    %timeit
    def sql_dataframe(self, query):
        logger.writing()
        try:
            df = pd.read_sql(query, self.engine)
        except:
            logger.fail()
        logger.success()
        return df

    def fetch_query_id(self, query_order=-1):
        logger.custom_log("fetching query id of order {ord}"\
            .format(ord=query_order)
        )
        try:
            df = pd.read_sql("select last_query_id({ord})"\
                .format(ord=query_order),self.engine)
        except:
            logger.fail()
            raise SnowflakeException("failed fetching query id")

        return df["QUERY_ID"][0]

    def cancel_query(self, query_id=fetch_query_id(-1)):
        try:
            self.engine.execute(r"select SYSTEM$CANCEL_QUERY('{queryID}')"\
                .format(queryID=query_id))
        finally:
            close_engine()

    def close_engine(self):
        self.engine.close()

    def get_metadata(self, schema_name, table_name):
        self.engine.execute("SELECT * FROM {}.{}".format(schema_name,table_name))
        return ','.join([col[0] for col in self.engine.description])
